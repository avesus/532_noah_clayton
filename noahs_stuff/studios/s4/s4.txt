Noah Goldstein

1)
#include "s4.h"


#define SUCCESS 0
#define FAILURE -1


int verbose = 0;

#define Version "0.1"

static ArgOption args[] = {
  // Kind, 	  Method,		name,	    reqd,  variable,		help
  { KindOption,   Integer, 		"-v", 	    0,     &verbose, 		"Set verbosity level" },
  { KindHelp,     Help, 	"-h" },
  { KindEnd }
};

static ArgDefs argp = { args, "s4", Version, NULL };

using namespace std;





int main(int argc, char* argv[]){
  progname = argv[0];
  ArgParser* ap = createArgumentParser(&argp);
  int result = parseArguments(ap, argc, argv);
  if(result){
    die("Error parsing arguments");
  }
  freeCommandLine();
  freeArgumentParser(ap);
  sync_list<int> sl;
  for(int i=0;i<100;i++){
    if(i&1){
      sl.push_back(i);
    }else{
      sl.push_front(i);
    }
  }
  for(int i=0;i<50;i++){
    cout << sl.pop_front() << endl;
  }
  for(int i=0;i<50;i++){
    cout << sl.pop_back() << endl;
  }
  return SUCCESS;
}

sync_list.cpp
#include "sync_list.h"

template <class T>
sync_list<T>::sync_list() : l() {

}

template <class T>
void sync_list<T>::push_back(T val){
  this->l.push_back(val);
}
template <class T>
T sync_list<T>::pop_back(){
  T ret = this->l.back();
  this->l.pop_back();
  return ret;
}

template <class T>
void sync_list<T>::push_front(T val){
  this->l.push_front(val);
}
template <class T>
T sync_list<T>::pop_front(){
  T ret = this->l.front();
  this->l.pop_front();
  return ret;
}


template class sync_list<int>;

sync_list.h
#ifndef _SYNC_LIST_H_
#define _SYNC_LIST_H_

#include <list>

template<class T>
class sync_list{
  std::list<T> l;
 public:
  sync_list();
  void push_back(T val);
  T pop_back();
  void push_front(T val);
  T pop_front();

};

#endif

output:
noah[09:17:43]:~/programs/classes/active/532/studios/s4$ /s4
98
96
94
92
90
88
86
84
82
80
78
76
74
72
70
68
66
64
62
60
58
56
54
52
50
48
46
44
42
40
38
36
34
32
30
28
26
24
22
20
18
16
14
12
10
8
6
4
2
0
99
97
95
93
91
89
87
85
83
81
79
77
75
73
71
69
67
65
63
61
59
57
55
53
51
49
47
45
43
41
39
37
35
33
31
29
27
25
23
21
19
17
15
13
11
9
7
5
3
1

3)

void pusher(sync_list<int>* sl){
 for(int i=0;i<100;i++){
    if(i&1){
      sl->push_back(i);
    }else{
      sl->push_front(i);
    }
  }
}

  sync_list<int> sl;
  vector<thread> t;
  for(int i=0;i<nthreads;i++){
    t.push_back(thread(pusher, &sl));
  }
  for(int i=0;i<nthreads;i++){
    t[i].join();
  }
  for(int i=0;i<50;i++){
    cout << sl.pop_front() << endl;
  }
  for(int i=0;i<50;i++){
    cout << sl.pop_back() << endl;
  }

output:
noah[09:18:43]:~/programs/classes/active/532/studios/s4$ ./s4
98
96
94
92
90
88
86
84
82
80
78
76
74
72
70
68
98
96
94
92
90
88
86
84
66
82
64
80
62
60
78
76
58
56
74
72
54
52
70
68
50
48
46
44
42
40
38
36
34
32
99
97
95
93
91
89
87
85
83
81
79
77
75
73
71
69
67
99
97
95
93
91
89
87
85
83
65
81
63
79
61
77
59
75
57
73
55
71
53
69
51
67
49
47
45
43
41
39
37
35

Clearly there is a race condition in adding new numbers. It seems that when the list was smaller (possibly resizing alot) most of the values were lost.

4)


void pusher_popper(sync_list<int>* sl){
 for(int i=0;i<100;i++){
    if(i&1){
      sl->push_back(i);
    }else{
      sl->push_front(i);
    }
  }
   for(int i=0;i<50;i++){
    cout << sl->pop_front() << endl;
  }
  for(int i=0;i<50;i++){
    cout << sl->pop_back() << endl;
  }
}

  sync_list<int> sl;
  vector<thread> t;
  for(int i=0;i<nthreads;i++){
    t.push_back(thread(pusher_popper, &sl));
  }
  for(int i=0;i<nthreads;i++){
    t[i].join();
  }

noah[09:26:33]:~/programs/classes/active/532/studios/s4$ ./s4
9898
96
94
92
38
36
34
42
76

98
96
94
92
82
2
14
8
14
20
52
58
64
72
80
44
98
98
90
38
70
98
44
7680

9894
9814

38
9648
58


96
9492988
88
86
84
82
80

78
9076
74

68
66
64
62
60
56
54
52
48
46
44
42
40
38
16
94
80
44
Segmentation fault (core dumped)

Crashes (parallel deletion is scary!). I.e race condition but now that race condition can cause bad memory reference


5)
template<class T>
class sync_list{
  std::list<T> l;

  std::mutex m;
  std::condition_variable cv;
 public:
  sync_list();
  void push_back(T val);
  T pop_back();
  void push_front(T val);
  T pop_front();

};


Difference is it appears to be race free for push/pop (runs smoothly!), and no more seg faults


6)
#include "sync_list.h"

template <class T>
sync_list<T>::sync_list() : l() {
  ubound = 0;
  lbound = 0;
}

template <class T>
sync_list<T>::sync_list(int u, int l) : sync_list() {
  ubound = u;
  lbound = l;
}

template <class T>
void sync_list<T>::push_back(T val){
  if(this->ubound){
    std::unique_lock<std::mutex> lock(this->m);
    while(this->l.size() > this->ubound){
      cv_push.wait(lock);
    }
    int to_notify = this->l.size() < this->lbound;
    this->l.push_back(val);
    if(to_notify){
      this->cv_pop.notify_one();
    }
  }else{
    std::lock_guard<std::mutex> lock(this->m);
    int to_notify = this->l.empty();
    this->l.push_back(val);
    if(to_notify){
      this->cv_pop.notify_one();
    }
  }
}




template <class T>
T sync_list<T>::pop_back(){
  if(this->lbound){
    std::unique_lock<std::mutex> lock(this->m);
    while(this->l.size() < this->lbound){
      cv_pop.wait(lock);
    }
    int to_notify = this->l.size() > this->ubound;
    T ret = this->l.back();
    this->l.pop_back();
    lock.unlock();
    if(to_notify){
      this->cv_push.notify_one();
    }
    return ret;
  }else{
    std::unique_lock<std::mutex> lock(this->m);
    while(this->l.empty()){
      cv_pop.wait(lock);
    }
    T ret = this->l.back();
    this->l.pop_back();
    lock.unlock();
    return ret;
  }
}

template <class T>
void sync_list<T>::push_front(T val){
  if(this->ubound){
    std::unique_lock<std::mutex> lock(this->m);
    while(this->l.size() > this->ubound){
      cv_push.wait(lock);
    }
    int to_notify = this->l.size() < this->lbound;
    this->l.push_front(val);
    if(to_notify){
      this->cv_pop.notify_one();
    }
  }else{
    std::lock_guard<std::mutex> lock(this->m);
    int to_notify = this->l.empty();
    this->l.push_front(val);
    if(to_notify){
      this->cv_pop.notify_one();
    }
  }
}


template <class T>
T sync_list<T>::pop_front(){
  if(this->lbound){
    std::unique_lock<std::mutex> lock(this->m);
    while(this->l.size() < this->lbound){
      cv_pop.wait(lock);
    }
    int to_notify = this->l.size() > this->ubound;
    T ret = this->l.back();
    this->l.pop_back();
    lock.unlock();
    if(to_notify){
      this->cv_push.notify_one();
    }
    return ret;
  }else{
    std::unique_lock<std::mutex> lock(this->m);
    while(this->l.empty()){
      cv_pop.wait(lock);
    }
    T ret = this->l.front();
    this->l.pop_front();
    lock.unlock();
    return ret;
  }
}



template class sync_list<int>;

.h:
#ifndef _SYNC_LIST_H_
#define _SYNC_LIST_H_

#include <list>
#include <mutex>
#include <condition_variable>

template<class T>
class sync_list{
  std::list<T> l;
  int ubound;
  int lbound;
  std::mutex m;
  std::condition_variable cv_pop;
  std::condition_variable cv_push;
 public:
  sync_list();
  sync_list(int u, int l);
  void push_back(T val);
  T pop_back();
  void push_front(T val);
  T pop_front();

};

#endif
