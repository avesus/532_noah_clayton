1.
Clayton Knittel and Noah Goldstein


2.

Output:
a:
00F9FA18: (0, 0)
00F9FA1C: (0, 1)
00F9FA20: (0, 2)
00F9FA24: (0, 3)
00F9FA28: (0, 4)
00F9FA2C: (0, 5)
00F9FA30: (0, 6)
00F9FA34: (0, 7)
00F9FA38: (0, 8)
00F9FA3C: (0, 9)
00F9FA40: (0, 10)
00F9FA44: (0, 11)
00F9FA48: (0, 12)
00F9FA4C: (0, 13)
00F9FA50: (0, 14)
00F9FA54: (0, 15)
00F9FA58: (1, 0)
00F9FA5C: (1, 1)
00F9FA60: (1, 2)
00F9FA64: (1, 3)
00F9FA68: (1, 4)
00F9FA6C: (1, 5)
00F9FA70: (1, 6)
00F9FA74: (1, 7)
00F9FA78: (1, 8)
00F9FA7C: (1, 9)
00F9FA80: (1, 10)
00F9FA84: (1, 11)
00F9FA88: (1, 12)
00F9FA8C: (1, 13)
00F9FA90: (1, 14)
00F9FA94: (1, 15)
00F9FA98: (2, 0)
00F9FA9C: (2, 1)
00F9FAA0: (2, 2)
00F9FAA4: (2, 3)
00F9FAA8: (2, 4)
00F9FAAC: (2, 5)
00F9FAB0: (2, 6)
00F9FAB4: (2, 7)
00F9FAB8: (2, 8)
00F9FABC: (2, 9)
00F9FAC0: (2, 10)
00F9FAC4: (2, 11)
00F9FAC8: (2, 12)
00F9FACC: (2, 13)
00F9FAD0: (2, 14)
00F9FAD4: (2, 15)
00F9FAD8: (3, 0)
00F9FADC: (3, 1)
00F9FAE0: (3, 2)
00F9FAE4: (3, 3)
00F9FAE8: (3, 4)
00F9FAEC: (3, 5)
00F9FAF0: (3, 6)
00F9FAF4: (3, 7)
00F9FAF8: (3, 8)
00F9FAFC: (3, 9)
00F9FB00: (3, 10)
00F9FB04: (3, 11)
00F9FB08: (3, 12)
00F9FB0C: (3, 13)
00F9FB10: (3, 14)
00F9FB14: (3, 15)

b:
00F9F910: (0, 0)
00F9F914: (0, 1)
00F9F918: (0, 2)
00F9F91C: (0, 3)
00F9F920: (0, 4)
00F9F924: (0, 5)
00F9F928: (0, 6)
00F9F92C: (0, 7)
00F9F930: (1, 0)
00F9F934: (1, 1)
00F9F938: (1, 2)
00F9F93C: (1, 3)
00F9F940: (1, 4)
00F9F944: (1, 5)
00F9F948: (1, 6)
00F9F94C: (1, 7)
00F9F950: (2, 0)
00F9F954: (2, 1)
00F9F958: (2, 2)
00F9F95C: (2, 3)
00F9F960: (2, 4)
00F9F964: (2, 5)
00F9F968: (2, 6)
00F9F96C: (2, 7)
00F9F970: (3, 0)
00F9F974: (3, 1)
00F9F978: (3, 2)
00F9F97C: (3, 3)
00F9F980: (3, 4)
00F9F984: (3, 5)
00F9F988: (3, 6)
00F9F98C: (3, 7)
00F9F990: (4, 0)
00F9F994: (4, 1)
00F9F998: (4, 2)
00F9F99C: (4, 3)
00F9F9A0: (4, 4)
00F9F9A4: (4, 5)
00F9F9A8: (4, 6)
00F9F9AC: (4, 7)
00F9F9B0: (5, 0)
00F9F9B4: (5, 1)
00F9F9B8: (5, 2)
00F9F9BC: (5, 3)
00F9F9C0: (5, 4)
00F9F9C4: (5, 5)
00F9F9C8: (5, 6)
00F9F9CC: (5, 7)
00F9F9D0: (6, 0)
00F9F9D4: (6, 1)
00F9F9D8: (6, 2)
00F9F9DC: (6, 3)
00F9F9E0: (6, 4)
00F9F9E4: (6, 5)
00F9F9E8: (6, 6)
00F9F9EC: (6, 7)
00F9F9F0: (7, 0)
00F9F9F4: (7, 1)
00F9F9F8: (7, 2)
00F9F9FC: (7, 3)
00F9FA00: (7, 4)
00F9FA04: (7, 5)
00F9FA08: (7, 6)
00F9FA0C: (7, 7)

c:
00F9F808: (0, 0)
00F9F80C: (0, 1)
00F9F810: (0, 2)
00F9F814: (0, 3)
00F9F818: (1, 0)
00F9F81C: (1, 1)
00F9F820: (1, 2)
00F9F824: (1, 3)
00F9F828: (2, 0)
00F9F82C: (2, 1)
00F9F830: (2, 2)
00F9F834: (2, 3)
00F9F838: (3, 0)
00F9F83C: (3, 1)
00F9F840: (3, 2)
00F9F844: (3, 3)
00F9F848: (4, 0)
00F9F84C: (4, 1)
00F9F850: (4, 2)
00F9F854: (4, 3)
00F9F858: (5, 0)
00F9F85C: (5, 1)
00F9F860: (5, 2)
00F9F864: (5, 3)
00F9F868: (6, 0)
00F9F86C: (6, 1)
00F9F870: (6, 2)
00F9F874: (6, 3)
00F9F878: (7, 0)
00F9F87C: (7, 1)
00F9F880: (7, 2)
00F9F884: (7, 3)
00F9F888: (8, 0)
00F9F88C: (8, 1)
00F9F890: (8, 2)
00F9F894: (8, 3)
00F9F898: (9, 0)
00F9F89C: (9, 1)
00F9F8A0: (9, 2)
00F9F8A4: (9, 3)
00F9F8A8: (10, 0)
00F9F8AC: (10, 1)
00F9F8B0: (10, 2)
00F9F8B4: (10, 3)
00F9F8B8: (11, 0)
00F9F8BC: (11, 1)
00F9F8C0: (11, 2)
00F9F8C4: (11, 3)
00F9F8C8: (12, 0)
00F9F8CC: (12, 1)
00F9F8D0: (12, 2)
00F9F8D4: (12, 3)
00F9F8D8: (13, 0)
00F9F8DC: (13, 1)
00F9F8E0: (13, 2)
00F9F8E4: (13, 3)
00F9F8E8: (14, 0)
00F9F8EC: (14, 1)
00F9F8F0: (14, 2)
00F9F8F4: (14, 3)
00F9F8F8: (15, 0)
00F9F8FC: (15, 1)
00F9F900: (15, 2)
00F9F904: (15, 3)


The arrays are laid out in row-major order, meaning the elements in each row are
contiguous, and the rows are laid out contiguously with respect to each other too

The formula for finding a memory location in a 2D array of dimension [M][N] would
then be
	array + (row * M + col)


3.

Used 8 threads, which was given by std::thread::hardware_concurrency()



count function:

static void count(int val, arr a, rect region) {
	int c = 0;
	for (int j = region.y; j < region.y + region.h; j++) {
		for (int i = region.x; i < region.x + region.w; i++) {
			if (a[j][i] == val) {
				c++;
			}
		}
	}
	lock_guard<mutex> g(m);
	cout << "found " << c << " occurrences of " << val << endl;
}


main function:

	vector<thread> threads;

	for (int i = 0; i < nthreads; i++) {
		arr ar((int**) a, 16, 4);
		rect r(0, 0, 16, 4);
		threads.push_back(thread(count, i, ar, r));
	}

	for (int i = 0; i < nthreads; i++) {
		threads[i].join();
	}

	threads.resize(0);

	for (int i = 0; i < nthreads; i++) {
		arr ar((int**)a, 16, 4);
		rect r(4 * (i % 4), 2 * (i / 4), 4, 2);
		threads.push_back(thread(count, 10, ar, r));
	}

	for (int i = 0; i < nthreads; i++) {
		threads[i].join();
	}


   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17
   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
spawining 8 threads
found 1 occurrences of 0
found 2 occurrences of 1
found 3 occurrences of 2
found 4 occurrences of 3
found 4 occurrences of 4
found 4 occurrences of 5
found 4 occurrences of 6
found 4 occurrences of 7
found 0 occurrences of 10
found 0 occurrences of 10
found 2 occurrences of 10
found 0 occurrences of 10
found 0 occurrences of 10
found 1 occurrences of 10
found 1 occurrences of 10
found 0 occurrences of 10



4.

Code:

static void matrix_add(arr a, arr b, arr c, rect region) {
	for (int j = region.y; j < region.y + region.h; j++) {
		for (int i = region.x; i < region.x + region.w; i++) {
			c[j][i] = a[j][i] + b[j][i];
		}
	}
}


in main:
	for (int i = 0; i < nthreads; i++) {
		arr ar((int**)a, 16, 4);
		arr yr((int**)y, 16, 4);
		arr rr((int**)res, 16, 4);
		rect r(4 * (i % 4), 2 * (i / 4), 4, 2);
		threads.push_back(thread(matrix_add, ar, yr, rr, r));
	}



5.

static void matrix_mult(arr a, rect arect, arr b, rect brect, arr c, rect crect) {
	assert(arect.w == brect.h);
	assert(arect.h == crect.h);
	assert(brect.w == crect.w);
	for (int j = 0; j < crect.h; j++) {
		for (int i = 0; i < crect.w; i++) {
			c[crect.y + j][crect.x + i] = 0;
			for (int k = 0; k < arect.w; k++) {
				c[crect.y + j][crect.x + i] += a[arect.y + j][arect.x + k] + b[brect.y + k][brect.x + i];
			}
		}
	}
}


in main:

	arr ar((int**)a, 16, 4);
	arr cr((int**)c, 8, 16);
	arr rr((int**)res, 8, 4);

	for (int i = 0; i < nthreads; i++) {
		rect are(0, 2 * (i / 4), 16, 2);
		rect bre(2 * (i % 4), 0, 2, 16);
		rect cre(2 * (i % 4), 2 * (i / 4), 2, 2);
		threads.push_back(thread(matrix_mult, ar, are, cr, bre, rr, cre));
	}


Output:
spawining 8 threads
   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17
   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
*
   0  -1  -2  -3  -4  -5  -6  -7
   1   0  -1  -2  -3  -4  -5  -6
   2   1   0  -1  -2  -3  -4  -5
   3   2   1   0  -1  -2  -3  -4
   4   3   2   1   0  -1  -2  -3
   5   4   3   2   1   0  -1  -2
   6   5   4   3   2   1   0  -1
   7   6   5   4   3   2   1   0
   8   7   6   5   4   3   2   1
   9   8   7   6   5   4   3   2
  10   9   8   7   6   5   4   3
  11  10   9   8   7   6   5   4
  12  11  10   9   8   7   6   5
  13  12  11  10   9   8   7   6
  14  13  12  11  10   9   8   7
  15  14  13  12  11  10   9   8
=
 240 224 208 192 176 160 144 128
 256 240 224 208 192 176 160 144
 272 256 240 224 208 192 176 160
 288 272 256 240 224 208 192 176


