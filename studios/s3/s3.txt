1) Noah Goldstein & Clayton Knittel

2)

#include "s3.h"


#define SUCCESS 0
#define FAILURE -1


int verbose = 0;
int inserts = 0;
int nthreads = 0;
#define Version "0.1"

static ArgOption args[] = {
  // Kind, 	  Method,		name,	    reqd,  variable,		help
  { KindOption,   Integer, 		"-v", 	    0,     &verbose, 		"Set verbosity level" },
  { KindOption,   Integer, 		"-t", 	    0,     &nthreads, 		"Set number of threads" },
  { KindOption,   Integer, 		"--inserts", 0,     &inserts, 		"Set number of inserts per thread" },
  { KindHelp,     Help, 	"-h" },
  { KindEnd }
};
static ArgDefs argp = { args, "s3", Version, NULL };

using namespace std;


class vwrapper {
  vector<int> v;
public:
  vwrapper operator<< (const int& a) {
    this->v.push_back(a);
    return *this;
  }
  int operator() () {
    int sum = 0;
    for(std::vector<int>::iterator it = this->v.begin();
	it != this->v.end();
	++it){
      sum += *it;
    }
    return sum;
  }

};

void doSum(vwrapper* vw){
  for(int i=0;i<inserts;i++){
    if(verbose){
      cout << "pushing back " << i << endl;
    }
    (*vw) << i;
  }
  if(verbose){
    cout << "sum: " << (*vw)() << endl;
  }
}

int main(int argc, char* argv[]){
  progname = argv[0];
  ArgParser* ap = createArgumentParser(&argp);
  int result = parseArguments(ap, argc, argv);
  if(result){
    die("Error parsing arguments");
  }
  freeCommandLine();
  freeArgumentParser(ap);
  if(inserts&&nthreads){
    vector<thread> threads;
    vwrapper vw;
    for(int i=0;i<nthreads;i++){
      threads.push_back(thread(doSum, &vw));
    }
    for(int i=0;i<nthreads;i++){
      threads[i].join();
    }
  }

  return SUCCESS;
}

noah[10:18:24]:~/programs/classes/active/532/studios/s3$ ./s3 -v 1 --inserts 10 -t 1
pushing back 0
pushing back 1
pushing back 2
pushing back 3
pushing back 4
pushing back 5
pushing back 6
pushing back 7
pushing back 8
pushing back 9
sum: 45

3)
noah[10:20:10]:~/programs/classes/active/532/studios/s3$ ./s3 -v 1 --inserts 10 -t 8
pushing back pushing back 0
0pushing back 1
pushing back 2
pushing back 3
pushing back 4
pushing back 5
pushing back 6

pushing back pushing back 7
0pushing back 8
pushing back 9
sum: 
45
pushing back pushing back 1
0
pushing back 1
pushing back 2
pushing back 3
pushing back 4
pushing back 5
pushing back 6
pushing back 7
pushing back 8
pushing back 9
sum: 91
pushing back 1
pushing back 2
pushing back 3
pushing back 4
pushing back 5
pushing back 6
pushing back 7
pushing back 8
pushing back 9
sum: 136
free(): invalid next size (normal)
s3: malloc.c:2401: sysmalloc: Assertion `(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)' failed.
Aborted (core dumped)

4)

#include "s3.h"


#define SUCCESS 0
#define FAILURE -1


int verbose = 0;
int inserts = 0;
int nthreads = 0;
#define Version "0.1"

static ArgOption args[] = {
  // Kind, 	  Method,		name,	    reqd,  variable,		help
  { KindOption,   Integer, 		"-v", 	    0,     &verbose, 		"Set verbosity level" },
  { KindOption,   Integer, 		"-t", 	    0,     &nthreads, 		"Set number of threads" },
  { KindOption,   Integer, 		"--inserts", 0,     &inserts, 		"Set number of inserts per thread" },
  { KindHelp,     Help, 	"-h" },
  { KindEnd }
};
static ArgDefs argp = { args, "s3", Version, NULL };

using namespace std;


class vwrapper {
  vector<int> v;
  mutex m;
public:
  vwrapper* operator<< (const int& a) {
    lock_guard<mutex> lock(this->m);
    this->v.push_back(a);
    //had an issue with mutex and returning object seems that going
    //out of scope would call delete on mutex which obviously is big
    //nono so changed to ptr
    return this;
  }
  int operator() () {
    lock_guard<mutex> lock(this->m);
    int sum = 0;
    for(std::vector<int>::iterator it = this->v.begin();
	it != this->v.end();
	++it){
      sum += *it;
    }
    return sum;
  }
  void print(const char* msg, ...){
    lock_guard<mutex> lock(this->m);
    va_list ap;
    va_start(ap, msg);
    vfprintf(stdout, msg, ap);
    va_end (ap);
  }

};

void doSum(vwrapper* vw, int tid){
  for(int i=0;i<inserts;i++){
    if(verbose){
      vw->print("Tid[%d] -> pushing back %d\n", tid, i);
    }
    (*vw) << i;
  }
  if(verbose){
    vw->print("Tid[%d] -> sum %d\n", tid, (*vw)());
  }
}

int main(int argc, char* argv[]){
  progname = argv[0];
  ArgParser* ap = createArgumentParser(&argp);
  int result = parseArguments(ap, argc, argv);
  if(result){
    die("Error parsing arguments");
  }
  freeCommandLine();
  freeArgumentParser(ap);
  if(inserts&&nthreads){
    vector<thread> threads;
    vwrapper vw;
    for(int i=0;i<nthreads;i++){
      threads.push_back(thread(doSum, &vw, i));
    }
    for(int i=0;i<nthreads;i++){
      threads[i].join();
    }
  }

  return SUCCESS;
}


noah[10:21:18]:~/programs/classes/active/532/studios/s3$ ./s3 -v 1 --inserts 10 -t 8
Tid[0] -> pushing back 0
Tid[1] -> pushing back 0
Tid[3] -> pushing back 0
Tid[3] -> pushing back 1
Tid[3] -> pushing back 2
Tid[3] -> pushing back 3
Tid[3] -> pushing back 4
Tid[3] -> pushing back 5
Tid[3] -> pushing back 6
Tid[3] -> pushing back 7
Tid[3] -> pushing back 8
Tid[3] -> pushing back 9
Tid[3] -> sum 45
Tid[6] -> pushing back 0
Tid[0] -> pushing back 1
Tid[4] -> pushing back 0
Tid[4] -> pushing back 1
Tid[4] -> pushing back 2
Tid[4] -> pushing back 3
Tid[4] -> pushing back 4
Tid[4] -> pushing back 5
Tid[7] -> pushing back 0
Tid[7] -> pushing back 1
Tid[7] -> pushing back 2
Tid[7] -> pushing back 3
Tid[7] -> pushing back 4
Tid[7] -> pushing back 5
Tid[7] -> pushing back 6
Tid[7] -> pushing back 7
Tid[7] -> pushing back 8
Tid[7] -> pushing back 9
Tid[7] -> sum 100
Tid[5] -> pushing back 0
Tid[5] -> pushing back 1
Tid[5] -> pushing back 2
Tid[5] -> pushing back 3
Tid[5] -> pushing back 4
Tid[5] -> pushing back 5
Tid[5] -> pushing back 6
Tid[5] -> pushing back 7
Tid[5] -> pushing back 8
Tid[5] -> pushing back 9
Tid[5] -> sum 145
Tid[6] -> pushing back 1
Tid[6] -> pushing back 2
Tid[6] -> pushing back 3
Tid[6] -> pushing back 4
Tid[6] -> pushing back 5
Tid[6] -> pushing back 6
Tid[6] -> pushing back 7
Tid[6] -> pushing back 8
Tid[6] -> pushing back 9
Tid[6] -> sum 190
Tid[1] -> pushing back 1
Tid[1] -> pushing back 2
Tid[1] -> pushing back 3
Tid[1] -> pushing back 4
Tid[1] -> pushing back 5
Tid[1] -> pushing back 6
Tid[1] -> pushing back 7
Tid[1] -> pushing back 8
Tid[1] -> pushing back 9
Tid[1] -> sum 235
Tid[4] -> pushing back 6
Tid[4] -> pushing back 7
Tid[4] -> pushing back 8
Tid[4] -> pushing back 9
Tid[2] -> pushing back 0
Tid[2] -> pushing back 1
Tid[2] -> pushing back 2
Tid[2] -> pushing back 3
Tid[2] -> pushing back 4
Tid[2] -> pushing back 5
Tid[2] -> pushing back 6
Tid[2] -> pushing back 7
Tid[2] -> pushing back 8
Tid[2] -> pushing back 9
Tid[2] -> sum 306
Tid[4] -> sum 315
Tid[0] -> pushing back 2
Tid[0] -> pushing back 3
Tid[0] -> pushing back 4
Tid[0] -> pushing back 5
Tid[0] -> pushing back 6
Tid[0] -> pushing back 7
Tid[0] -> pushing back 8
Tid[0] -> pushing back 9
Tid[0] -> sum 360

6)
There is an issue with overflow (so fact of large numbers is often -
or 0) but aside from that the only todo was to push the actual
contents of sum in a non-locking helper (then have that be called by
'()' operator or 'factorial_of_sum()'.

7)
#include "s3.h"


#define SUCCESS 0
#define FAILURE -1


int verbose = 0;
int inserts = 0;
int nthreads = 0;
#define Version "0.1"

static ArgOption args[] = {
  // Kind, 	  Method,		name,	    reqd,  variable,		help
  { KindOption,   Integer, 		"-v", 	    0,     &verbose, 		"Set verbosity level" },
  { KindOption,   Integer, 		"-t", 	    0,     &nthreads, 		"Set number of threads" },
  { KindOption,   Integer, 		"--inserts", 0,     &inserts, 		"Set number of inserts per thread" },
  { KindHelp,     Help, 	"-h" },
  { KindEnd }
};
static ArgDefs argp = { args, "s3", Version, NULL };

using namespace std;

template <class T> 
class vwrapper {
  vector<int> v;
  T m;
public:
  vwrapper* operator<< (const int& a) {
    lock_guard<T> lock(this->m);
    this->v.push_back(a);
    //had an issue with mutex and returning object seems that going
    //out of scope would call delete on mutex which obviously is big
    //nono so changed to ptr
    return this;
  }
  int operator() () {
    lock_guard<T> lock(this->m);
    return this->sum();
  }
  
  int sum(){
    int sum = 0;
    for(std::vector<int>::iterator it = this->v.begin();
	it != this->v.end();
	++it){
      sum += *it;
    }
    return sum;
  }
  
  void print(const char* msg, ...){
    lock_guard<T> lock(this->m);
    va_list ap;
    va_start(ap, msg);
    vfprintf(stdout, msg, ap);
    va_end (ap);
  }
  unsigned long factorial_of_sum(){
    lock_guard<T> lock(this->m);
    int sum = this->sum();
    unsigned long fact = 1;
    for(int i=1;i<=sum;i++){
      fact *= i;
    }
    return fact;
  }
  thread new_thread(int tid){
    //this was a serious RTFM moment
    return thread(&vwrapper::doSum, this, tid);
  }
  
  void doSum(int tid){
    for(int i=0;i<inserts;i++){
      if(verbose){
	this->print("Tid[%d] -> pushing back %d\n", tid, i);
      }
      (*this) << i;
    }
    if(verbose){
      this->print("Tid[%d] -> sum %d\n", tid, (*this)());
      //this is bound to overflow
      this->print("Tid[%d] -> fact %lu\n", tid, this->factorial_of_sum());
    }
  }
  
};





int main(int argc, char* argv[]){
  progname = argv[0];
  ArgParser* ap = createArgumentParser(&argp);
  int result = parseArguments(ap, argc, argv);
  if(result){
    die("Error parsing arguments");
  }
  freeCommandLine();
  freeArgumentParser(ap);
  if(inserts&&nthreads){
    vector<thread> threads;
    vwrapper<recursive_mutex> vw;
    for(int i=0;i<nthreads;i++){
      threads.push_back(vw.new_thread(i));
    }
    for(int i=0;i<nthreads;i++){
      threads[i].join();
    }
  }

  return SUCCESS;
}

No difference in executation. I did not have deadlock/data race before
and do not now
